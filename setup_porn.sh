#!/bin/bash

# ==============================================================================
# SEARCHXX_PROJECT - SETUP SCRIPT
# ==============================================================================
#
# This script generates a Node.js web application (in the 'searchxx_project'
# directory) for searching adult content.
#
# Key Characteristics:
# --------------------
# 1.  **Backend (`server.cjs`):**
#     The main server logic in `server.cjs` primarily uses the `pornsearch`
#     npm library to perform searches across various adult video websites.
#     This library acts as an abstraction layer over the individual sites.
#
# 2.  **`pornsearch` Library Dependency:**
#     The functionality of this application heavily relies on the `pornsearch`
#     npm library. If this library is not maintained or becomes outdated,
#     the search functionality for a_search_engine_services may be affected.
#
# 3.  **Additional Custom Scraper Framework (Example/Alternative):**
#     This script also generates a set of custom scraper modules (e.g.,
#     modules/Redtube.js, modules/Pornhub.js) and associated core files
#     (core/AbstractModule.js, etc.). These modules seem to represent an
#     alternative, custom-built scraping framework that would use direct HTML
#     scraping (likely intended for use with libraries like axios and cheerio,
#     though not explicitly installed by this script for *these specific* modules).
#     **However, the primary `server.cjs` file, as generated by this script,
#     does NOT use these custom `modules/` scrapers. It uses `pornsearch`.**
#     These custom modules might serve as examples, a basis for future
#     development, or part of a different intended use case.
#
# Basic Post-Setup Instructions:
# ------------------------------
# 1. Run this script: `bash setup_porn.sh`
# 2. Navigate to the project directory: `cd searchxx_project`
# 3. Install dependencies: `npm install` (installs express, pornsearch, cors, dotenv)
# 4. Run the server: `node server.cjs`
# 5. Open your browser to `http://localhost:3001` (or the port in .env).
#
# ==============================================================================


# Exit immediately if a command exits with a non-zero status.
set -e
# Treat unset variables as an error when substituting.
set -u
# The return value of a pipeline is the status of the last command to exit with a non-zero status,
# or zero if no command exited with a non-zero status.
set -o pipefail

PROJECT_NAME="searchxx_project"
FRONTEND_HTML_FILE="index.html" # Renamed from pornx.html for convention

# --- Helper Functions ---
info() {
    echo -e "\033[1;34m[INFO]\033[0m $1"
}

success() {
    echo -e "\033[1;32m[SUCCESS]\033[0m $1"
}

warning() {
    echo -e "\033[1;33m[WARNING]\033[0m $1"
}

error_exit() {
    echo -e "\033[1;31m[ERROR]\033[0m $1" >&2
    exit 1
}

# --- Main Script ---
info "Starting setup for $PROJECT_NAME..."

# Check if project directory already exists
if [ -d "$PROJECT_NAME" ]; then
    warning "Directory '$PROJECT_NAME' already exists."
    read -r -p "Do you want to remove it and recreate? (y/N): " confirmation
    if [[ "$confirmation" =~ ^[Yy]$ ]]; then
        info "Removing existing directory '$PROJECT_NAME'..."
        rm -rf "$PROJECT_NAME"
    else
        info "Setup aborted by user."
        exit 0
    fi
fi

info "Creating project directory: $PROJECT_NAME"
mkdir -p "$PROJECT_NAME"
cd "$PROJECT_NAME" || error_exit "Failed to cd into $PROJECT_NAME"

info "Creating subdirectories: core, modules"
mkdir -p core modules

info "Initializing Node.js project..."
npm init -y > /dev/null # Suppress npm init output

info "Installing dependencies: express, pornsearch, cors, dotenv..."
npm install express pornsearch cors dotenv --silent > /dev/null # Suppress npm install output

# --- Create .env file ---
info "Creating .env file..."
cat << 'EOF' > .env
PORT=3001
# Add other environment variables here if needed
EOF

# --- Create .gitignore file ---
info "Creating .gitignore file..."
cat << 'EOF' > .gitignore
# Dependencies
node_modules/

# Environment variables
.env

# Logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db
EOF

# --- Create server.cjs ---
info "Creating server.cjs..."
cat << 'EOF' > server.cjs
// server.cjs - Backend Server for Search Functionality

// --- Setup & Dependencies ---
require('dotenv').config(); // Load environment variables from .env file

const express = require('express');
const Pornsearch = require('pornsearch'); // Core search library
const cors = require('cors'); // Enable Cross-Origin Resource Sharing
const path = require('path'); // Utility for handling file paths

// --- Constants ---
const app = express();
const PORT = process.env.PORT || 3001; // Use 3001 as default to avoid common conflicts with frontend dev servers

// Define allowed search drivers and types
const ALLOWED_DRIVERS = Object.freeze(['pornhub', 'sex', 'redtube', 'xvideos']); // Use Object.freeze for immutability
const ALLOWED_TYPES = Object.freeze(['videos', 'gifs']);
const DEFAULT_TYPE = 'videos'; // Default search type

// --- Logging Configuration ---
// ANSI escape codes for styled console output
const LOG_STYLES = Object.freeze({
    RESET: '\u001b[0m',
    BOLD: '\u001b[1m',
    DIM: '\u001b[2m',
    RED: '\u001b[31m',
    GREEN: '\u001b[32m',
    YELLOW: '\u001b[33m',
    BLUE: '\u001b[34m',
    CYAN: '\u001b[36m',
    WHITE: '\u001b[37m',
});

// Define log prefixes with styles
const LOG_PREFIX = Object.freeze({
    API: `${LOG_STYLES.BLUE}API${LOG_STYLES.RESET}`,
    WARN: `${LOG_STYLES.BOLD}${LOG_STYLES.YELLOW}Warning${LOG_STYLES.RESET}`,
    NOTE: `${LOG_STYLES.DIM}${LOG_STYLES.WHITE}Note${LOG_STYLES.RESET}`,
    REQUEST: `${LOG_STYLES.BOLD}${LOG_STYLES.CYAN}Request${LOG_STYLES.RESET}`,
    SEARCH: `${LOG_STYLES.DIM}${LOG_STYLES.WHITE}--> Searching${LOG_STYLES.RESET}`,
    SUCCESS: `${LOG_STYLES.BOLD}${LOG_STYLES.GREEN}<-- Found${LOG_STYLES.RESET}`,
    ERROR: `${LOG_STYLES.BOLD}${LOG_STYLES.RED}!!! Error${LOG_STYLES.RESET}`,
    SERVER: `${LOG_STYLES.BOLD}${LOG_STYLES.GREEN}Server${LOG_STYLES.RESET}`,
    INFO: `${LOG_STYLES.BOLD}${LOG_STYLES.CYAN}Info${LOG_STYLES.RESET}`
});

/**
 * Helper function for consistent styled logging.
 * @param {keyof LOG_PREFIX} level - The log level (e.g., 'API', 'WARN').
 * @param {string} message - The main log message.
 * @param {any} [details] - Optional additional details to log.
 */
const log = (level, message, details) => {
    const timestamp = new Date().toLocaleTimeString();
    // Use the level key directly if it exists in LOG_PREFIX, otherwise use the level string itself
    const levelPrefix = LOG_PREFIX[level] || level;
    const logPrefix = `[${timestamp}] ${levelPrefix}:`;

    if (details !== undefined) {
        // Log details on a new line for better readability, especially for objects/errors
        console.log(`${logPrefix} ${message}`);
        console.log(details);
    } else {
        console.log(`${logPrefix} ${message}`);
    }
};

// --- Middleware ---
app.use(cors()); // Enable CORS for all origins (consider restricting in production)
app.use(express.json()); // Parse JSON request bodies
// Serve static files (like a frontend HTML page) from the project's root directory
// This will serve index.html when accessing the root URL if available.
app.use(express.static(path.resolve(__dirname)));

// --- Root Route ---
// This will be overridden by index.html if it exists in the root due to express.static
app.get('/', (req, res) => {
    // Provide a clear status message and basic instructions
    res.status(200).send(
        'Search Server Backend is running.\n' +
        `API Endpoint: /api/search?query=...&driver=...[&type=videos|gifs][&page=1]\n` +
        `Frontend: Should be served from root (e.g., /index.html)`
    );
});

// --- API Search Endpoint ---
app.get('/api/search', async (req, res) => {
    // Extract and sanitize query parameters
    const query = req.query.query ? String(req.query.query).trim() : '';
    const driver = req.query.driver ? String(req.query.driver).toLowerCase().trim() : '';
    const type = req.query.type ? String(req.query.type).toLowerCase().trim() : DEFAULT_TYPE;
    const page = req.query.page;

    // --- Input Validation ---

    // 1. Validate mandatory parameters
    if (!query || !driver) {
        const missingParams = [];
        if (!query) missingParams.push("'query'");
        if (!driver) missingParams.push("'driver'");
        const errorMessage = `Missing required query parameter(s): ${missingParams.join(' and ')}.`;
        log('WARN', errorMessage, req.query);
        return res.status(400).json({ error: errorMessage });
    }

    // 2. Validate driver
    if (!ALLOWED_DRIVERS.includes(driver)) {
        const errorMessage = `Invalid driver '${driver}'. Allowed drivers are: ${ALLOWED_DRIVERS.join(', ')}.`;
        log('WARN', errorMessage);
        return res.status(400).json({ error: errorMessage });
    }

    // 3. Validate and normalize search type
    let searchType = type;
    if (!ALLOWED_TYPES.includes(searchType)) {
        log('NOTE', `Invalid or missing 'type' parameter ('${type}'). Defaulting to '${DEFAULT_TYPE}'.`);
        searchType = DEFAULT_TYPE; // Default to videos if invalid or missing
    }

    // 4. Validate and parse page number
    let pageNumber = parseInt(page, 10);
    if (isNaN(pageNumber) || pageNumber < 1) {
        if (page !== undefined) { // Log only if page was provided but invalid
            log('NOTE', `Invalid or missing 'page' parameter ('${page}'). Defaulting to page 1.`);
        }
        pageNumber = 1; // Default to page 1
    }

    log('REQUEST', `Query="${query}", Driver=${driver}, Type=${searchType}, Page=${pageNumber}`);

    try {
        // --- Perform Search ---
        log('SEARCH', `${searchType === 'gifs' ? 'GIFs' : 'Videos'} on ${driver} (Page ${pageNumber})...`);
        const search = new Pornsearch(query, driver);
        let results;

        // Call the appropriate search method based on type
        if (searchType === 'gifs') {
            results = await search.gifs(pageNumber);
        } else { // Default to videos
            results = await search.videos(pageNumber);
        }

        // Ensure results is always an array, even if the library returns null/undefined
        const finalResults = Array.isArray(results) ? results : [];
        const resultCount = finalResults.length;
        log('SUCCESS', `${resultCount} ${searchType}(s) found for query="${query}", driver=${driver}, page=${pageNumber}.`);

        // Send results to the client
        res.status(200).json(finalResults);

    } catch (error) {
        // --- Error Handling ---
        log('ERROR', `Search failed [Type: ${searchType}, Driver: ${driver}, Page: ${pageNumber}, Query: "${query}"]`, error.message || error);
        // Avoid logging the full error object to console in production if it might contain sensitive info
        // console.error(error); // Uncomment for full stack trace during development/debugging

        let errorMessage = 'An unexpected error occurred while fetching search results.';
        let statusCode = 500; // Internal Server Error

        // Attempt to provide more specific feedback based on the error
        // Note: Relying on error message strings is fragile and might break if the library changes its error messages.
        const lowerCaseErrorMessage = error.message ? String(error.message).toLowerCase() : '';

        if (error.response?.status === 404 || lowerCaseErrorMessage.includes('not found') || lowerCaseErrorMessage.includes('no results')) {
            errorMessage = `Could not find results or page ${pageNumber} for ${searchType} on '${driver}'. The page may not exist, the query yielded no results, or the content type is unavailable.`;
            statusCode = 404; // Not Found
        } else if (lowerCaseErrorMessage.includes('driver') || lowerCaseErrorMessage.includes('support') || lowerCaseErrorMessage.includes('method') || lowerCaseErrorMessage.includes('not implemented')) {
            errorMessage = `The search provider '${driver}' may not support searching for ${searchType}, or an internal library error occurred.`;
            statusCode = 501; // Not Implemented (or 400 Bad Request if type is fundamentally unsupported)
        } else if (lowerCaseErrorMessage.includes('parse') || lowerCaseErrorMessage.includes('selector') || lowerCaseErrorMessage.includes('structure') || lowerCaseErrorMessage.includes('cannot read properties of undefined')) {
            // This often indicates the website structure changed, breaking the scraper
            errorMessage = `Failed to parse ${searchType} data from '${driver}'. The site's structure may have changed, temporarily breaking search for this provider.`;
            statusCode = 502; // Bad Gateway (issue with the upstream service/scraping)
        } else if (error.code === 'ENOTFOUND' || error.code === 'ECONNREFUSED' || error.code === 'ETIMEDOUT' || lowerCaseErrorMessage.includes('timeout')) {
            errorMessage = `Could not connect to '${driver}' or the connection timed out. The site might be down or unreachable.`;
            statusCode = 504; // Gateway Timeout
        } else if (error.response?.status === 429 || lowerCaseErrorMessage.includes('many requests')) {
            errorMessage = `Too many requests sent to '${driver}'. Please wait a moment before trying again.`;
            statusCode = 429; // Too Many Requests
        }
        // Add more specific error checks based on observed errors from the Pornsearch library if needed

        res.status(statusCode).json({
            error: errorMessage,
            // Optionally include details in non-production environments
            // details: process.env.NODE_ENV !== 'production' ? error.message : undefined
        });
    }
});

// --- Start Server ---
app.listen(PORT, () => {
    const host = `http://localhost:${PORT}`;
    log('SERVER', `Backend server listening on port ${LOG_STYLES.BOLD}${LOG_STYLES.YELLOW}${PORT}${LOG_STYLES.RESET}`);
    log('INFO', `Allowed Drivers: ${LOG_STYLES.BOLD}${LOG_STYLES.YELLOW}${ALLOWED_DRIVERS.join(', ')}${LOG_STYLES.RESET}`);
    log('INFO', `Allowed Types:   ${LOG_STYLES.BOLD}${LOG_STYLES.YELLOW}${ALLOWED_TYPES.join(', ')}${LOG_STYLES.RESET}`);
    log('INFO', `API Endpoint:    ${LOG_STYLES.BOLD}${LOG_STYLES.YELLOW}${host}/api/search${LOG_STYLES.RESET}`);
    log('INFO', `Server Status:   ${LOG_STYLES.BOLD}${LOG_STYLES.YELLOW}${host}/${LOG_STYLES.RESET}`);
    console.log(`(${LOG_STYLES.DIM}${LOG_STYLES.WHITE}Press Ctrl+C to stop the server${LOG_STYLES.RESET})`);
});

// --- Graceful Shutdown (Optional but Recommended) ---
process.on('SIGINT', () => {
    log('SERVER', 'Shutdown signal received, closing server gracefully.');
    // Perform cleanup here if needed (e.g., close database connections)
    process.exit(0);
});

process.on('SIGTERM', () => {
    log('SERVER', 'Termination signal received, closing server gracefully.');
    // Perform cleanup here if needed
    process.exit(0);
});
EOF

# --- Create core/OverwriteError.js ---
info "Creating core/OverwriteError.js..."
cat << 'EOF' > core/OverwriteError.js
// core/OverwriteError.js
'use strict';

class OverwriteError extends Error {
  constructor(message) {
    super(message);
    this.name = 'OverwriteError';
    // Maintains proper prototype chain for instanceof checks
    Object.setPrototypeOf(this, OverwriteError.prototype);
  }
}

module.exports = OverwriteError;
EOF

# --- Create core/abstractMethodFactory.js ---
info "Creating core/abstractMethodFactory.js..."
cat << 'EOF' > core/abstractMethodFactory.js
// core/abstractMethodFactory.js
'use strict';

const OverwriteError = require('./OverwriteError');

/**
 * @typedef {new (...args: any[]) => object} BaseClassConstructor - Represents a base class constructor.
 * @template TBase - The type of the base class instances.
 */

/**
 * Factory function that takes a base class constructor and a list of method names.
 * It returns a new class constructor that inherits from the base class and enforces that
 * the specified methods must be implemented by any concrete subclass.
 *
 * @param {BaseClassConstructor<TBase>} BaseClass - The constructor function of the base class to inherit from.
 * @param {string[]} abstractMethods - An array of method names that must be implemented by subclasses.
 * @returns {BaseClassConstructor<TBase>} A new class constructor extending BaseClass.
 * @template TBase - The instance type of the base class.
 * @throws {Error} If BaseClass is not a valid constructor or if abstractMethods is not a non-empty array of valid strings.
 */
module.exports = (BaseClass, abstractMethods) => {
  if (typeof BaseClass !== 'function') {
    throw new Error('The first argument "BaseClass" must be a constructor function.');
  }

  if (!Array.isArray(abstractMethods) || abstractMethods.length === 0) {
    throw new Error('The second argument "abstractMethods" must be a non-empty array of strings.');
  }

  const validAbstractMethods = abstractMethods.filter(methodName =>
    typeof methodName === 'string' && methodName.trim().length > 0
  );

  if (validAbstractMethods.length === 0) {
    throw new Error('After filtering invalid entries, the "abstractMethods" array is empty or contains only invalid method names.');
  }

  const AbstractMethodEnforcer = class extends BaseClass {
    constructor(...args) {
      super(...args);
    }
  };

  validAbstractMethods.forEach(methodName => {
    Object.defineProperty(AbstractMethodEnforcer.prototype, methodName, {
      get() {
        // This getter is invoked when the 'abstract' method is accessed.
        // It returns the function that will actually be called.
        return (...args) => {
          // 'this' here refers to the instance of the concrete subclass.
          const callingClassName = this.constructor.name || 'Subclass';
          // BaseClass.name might not be reliable if BaseClass is an anonymous class from prior mixin application.
          // It's more about the *concept* of the layer that introduced the abstract method.
          throw new OverwriteError(
            `Abstract method "${methodName}" must be implemented by concrete class "${callingClassName}".`
          );
        };
      },
      configurable: true, // Allows subclasses to override.
      enumerable: false,   // Keeps it off for...in loops on the prototype.
    });
  });

  return AbstractMethodEnforcer;
};
EOF

# --- Create core/AbstractModule.js ---
info "Creating core/AbstractModule.js..."
cat << 'EOF' > core/AbstractModule.js
// core/AbstractModule.js
'use strict';

class AbstractModule {
  /**
   * @param {string} query - The search query.
   */
  constructor(query) {
    if (typeof query !== 'string') { // Basic check, concrete classes might do more
      this.query = '';
    } else {
      this.query = query.trim();
    }
    // Other common initializations can go here (e.g., HTTP client instance)
  }

  /**
   * Getter for the module's name. Must be implemented by subclasses.
   * @abstract
   * @returns {string}
   */
  get name() {
    throw new Error(`Getter "name" must be implemented by subclass "${this.constructor.name}".`);
  }

  /**
   * Getter for the first page number (pagination).
   * Defaults to 0, can be overridden by subclasses.
   * @returns {number}
   */
  get firstpage() {
    return 0;
  }

  /**
   * Static method to apply mixins to a class.
   * @param {...Function} mixinFactories - Mixin factory functions (e.g., VideoMixin, GifMixin).
   * @returns {Function} A new class composed with the applied mixins.
   */
  static with(...mixinFactories) {
    // 'this' refers to the class calling 'with' (e.g., AbstractModule or a class already extended by mixins)
    return mixinFactories.reduce((c, mixinFactory) => mixinFactory(c), this);
  }

  // Example of a utility method subclasses might use (requires http client injection)
  // async _fetchPage(url) {
  //   if (!this.httpClient) throw new Error("HTTP client not available on this module.");
  //   const response = await this.httpClient.get(url);
  //   return response.data; // Or response.text()
  // }
}

module.exports = AbstractModule;
EOF

# --- Create core/VideoMixin.js ---
info "Creating core/VideoMixin.js..."
cat << 'EOF' > core/VideoMixin.js
// core/VideoMixin.js
'use strict';

const enforceAbstractMethods = require('./abstractMethodFactory');

const videoAbstractMethods = [
  'videoUrl',    // Expected to return a string (URL)
  'videoParser', // Expected to parse data (e.g., from HTML or JSON) and return an array of video objects
];

/**
 * VideoMixin - A factory function that creates a mixin to add video-related requirements.
 * @param {Function} BaseClass - The base class constructor to extend.
 * @returns {Function} A new class constructor with enforced abstract methods for videos.
 */
const VideoMixin = (BaseClass) => {
  return enforceAbstractMethods(BaseClass, videoAbstractMethods);
};

module.exports = VideoMixin;
EOF

# --- Create core/GifMixin.js ---
info "Creating core/GifMixin.js..."
cat << 'EOF' > core/GifMixin.js
// core/GifMixin.js
'use strict';

const enforceAbstractMethods = require('./abstractMethodFactory'); // Path based on file structure

const gifAbstractMethods = [
  'gifUrl',
  'gifParser'
];

/**
 * GifMixin - A factory function that creates a mixin to add GIF-related requirements.
 * @param {Function} BaseClass - The base class constructor to extend.
 * @returns {Function} A new class constructor with enforced abstract methods for GIFs.
 */
const GifMixin = (BaseClass) => {
  return enforceAbstractMethods(BaseClass, gifAbstractMethods);
};

module.exports = GifMixin;
EOF

# --- Create modules/Redtube.js ---
info "Creating modules/Redtube.js..."
cat << 'EOF' > modules/Redtube.js
// modules/Redtube.js
'use strict';

const AbstractModule = require('../core/AbstractModule');
const VideoMixin = require('../core/VideoMixin');

// Base class composed with VideoMixin requirements
const BaseScraper = AbstractModule.with(VideoMixin);

class Redtube extends BaseScraper {
  constructor(query) {
    super(query); // Passes query to AbstractModule constructor
    // No Redtube-specific constructor logic needed here for now
  }

  get name() {
    return 'Redtube';
  }

  get firstpage() {
    return 1; // Redtube API pagination typically starts at 1
  }

  /**
   * Generates the API URL for Redtube video search.
   * @param {number} [page] - The page number. Defaults to `this.firstpage`.
   * @returns {string} The API URL.
   */
  videoUrl(page) {
    const pageNum = (Number.isInteger(page) && page >= this.firstpage) ? page : this.firstpage;
    // Using HTTPS for API endpoint
    return `https://api.redtube.com/?data=redtube.Videos.searchVideos&output=json&search=${encodeURIComponent(this.query)}&thumbsize=big&page=${pageNum}`;
  }

  /**
   * Parses the JSON response from Redtube API.
   * @param {object} jsonData - The parsed JSON data from the API response.
   * @returns {Array<object>} An array of video objects.
   */
  videoParser(jsonData) {
    if (!jsonData || !Array.isArray(jsonData.videos)) {
      // console.warn(`[${this.name}] Invalid or empty JSON data received for video parsing.`);
      return [];
    }

    return jsonData.videos.map(({ video }) => {
      if (!video) return null; // Skip if video object is missing
      return {
        title: video.title,
        url: video.url,
        duration: video.duration,
        thumb: video.default_thumb, // API provides 'default_thumb'
        source: this.name,
      };
    }).filter(video => video !== null); // Remove any null entries
  }
}

module.exports = Redtube;
EOF

# --- Create modules/SexCom.js ---
info "Creating modules/SexCom.js..."
cat << 'EOF' > modules/SexCom.js
// modules/SexCom.js
'use strict';

const AbstractModule = require('../core/AbstractModule');
const VideoMixin = require('../core/VideoMixin');
const GifMixin = require('../core/GifMixin');
// const cheerio = require('cheerio'); // Would be required if loading HTML here

// Base class composed with both GifMixin and VideoMixin requirements
const BaseScraper = AbstractModule.with(GifMixin, VideoMixin);

class SexCom extends BaseScraper {
  constructor(query) {
    super(query);
    this.baseUrl = 'https://www.sex.com'; // Use HTTPS
  }

  get name() {
    return 'Sex.com'; // Display name
  }

  get firstpage() {
    return 1; // Sex.com pagination starts at 1
  }

  /**
   * @param {number} [page]
   * @returns {string}
   */
  videoUrl(page) {
    const pageNum = (Number.isInteger(page) && page >= this.firstpage) ? page : this.firstpage;
    return `${this.baseUrl}/search/videos?query=${encodeURIComponent(this.query)}&page=${pageNum}`;
  }

  /**
   * @param {number} [page]
   * @returns {string}
   */
  gifUrl(page) {
    const pageNum = (Number.isInteger(page) && page >= this.firstpage) ? page : this.firstpage;
    return `${this.baseUrl}/search/gifs?query=${encodeURIComponent(this.query)}&page=${pageNum}`;
  }

  /**
   * Parses video data from Sex.com HTML.
   * @param {import('cheerio').CheerioAPI} $ - Cheerio instance loaded with page HTML.
   * @returns {Array<object>}
   */
  videoParser($) {
    if (typeof $ !== 'function') {
      // console.warn(`[${this.name}] Cheerio instance not provided to videoParser.`);
      return [];
    }
    const videos = [];
    $('#masonry_container .masonry_box').each((_, element) => {
      const cached = $(element);
      const link = cached.find('.title a').first();
      const title = link.text()?.trim();
      const duration = cached.find('.duration').text()?.trim();
      const thumb = cached.find('.image[data-src]').data('src')?.trim(); // data-src for lazy loaded images
      const path = link.attr('href');

      if (title && path && duration && thumb) {
        videos.push({
          title,
          url: path.startsWith('http') ? path : `${this.baseUrl}${path}`,
          duration,
          thumb: thumb.startsWith('http') ? thumb : (thumb.startsWith('//') ? `https:${thumb}` : thumb),
          source: this.name,
        });
      }
    });
    return videos;
  }

  /**
   * Parses GIF data from Sex.com HTML.
   * @param {import('cheerio').CheerioAPI} $ - Cheerio instance loaded with page HTML.
   * @returns {Array<object>}
   */
  gifParser($) {
    if (typeof $ !== 'function') {
      // console.warn(`[${this.name}] Cheerio instance not provided to gifParser.`);
      return [];
    }
    const gifs = [];
    $('#masonry_container .masonry_box').not('.ad_box').each((_, element) => {
      const data = $(element).find('a.image_wrapper').first();
      const title = data.attr('title')?.trim();
      // GIF URL is often directly in data-src of an img inside the anchor
      const url = data.find('img[data-src]').data('src')?.trim();
      // Sex.com doesn't typically provide a separate .webm for search results directly,
      // the 'url' is the direct GIF.
      if (title && url) {
        gifs.push({
          title,
          url: url.startsWith('http') ? url : (url.startsWith('//') ? `https:${url}` : url),
          // webm: typically not available directly in Sex.com GIF search listings, might be on detail page.
          source: this.name,
        });
      }
    });
    return gifs;
  }
}

module.exports = SexCom;
EOF

# --- Create modules/Pornhub.js ---
info "Creating modules/Pornhub.js..."
cat << 'EOF' > modules/Pornhub.js
'use strict';

// Core dependencies - these better be rock solid!
const AbstractModule = require('../core/AbstractModule');
const GifMixin = require('../core/GifMixin');
const VideoMixin = require('../core/VideoMixin');

// We're assuming Cheerio is ready to roll, but not directly calling it here.
// const cheerio = require('cheerio');

/**
 * @typedef {import('cheerio').CheerioAPI} CheerioAPI
 */

/**
 * @typedef {object} VideoResult - The goods: what we found for videos.
 * @property {string} title - What's it called?
 * @property {string} url - Where's it at? (Full URL)
 * @property {string} duration - How long is the... show?
 * @property {string} thumb - A little peek (thumbnail URL).
 * @property {string} source - Where'd this gem come from? (e.g., 'Pornhub')
 */

/**
 * @typedef {object} GifResult - Quick loops of fun.
 * @property {string} title - GIF's catchy name.
 * @property {string} url - Direct link to the .gif prize.
 * @property {string} webm - The smoother, better WEBM version.
 * @property {string} source - Source, again.
 */

/**
 * Pornhub.com Scraper - This is where the magic happens for PH.
 * Built on our awesome AbstractModule and spiced up with Gif & Video Mixins.
 *
 * @class Pornhub
 * @extends AbstractModule // More like AbstractModule + Mixins extravaganza!
 * @mixes GifMixin
 * @mixes VideoMixin
 */
class Pornhub extends AbstractModule.with(GifMixin, VideoMixin) {
  /**
   * Fires up the Pornhub engine.
   * @param {string} query - What are you searching for, champ?
   * @throws {Error} If you don't give me a proper query.
   */
  constructor(query) {
    super(query); // Let the base class and mixins handle the query first.

    if (!query || typeof query !== 'string' || query.trim() === '') {
      throw new Error('Pornhub driver needs a non-empty search query. No query, no party!');
    }
    // this.query is assumed to be set by super(query) from AbstractModule/Mixins.
    // If not, you'd explicitly set something like this.rawQuery = query.trim();

    this.baseUrl = 'https://www.pornhub.com'; // HTTPS all the way, baby!
    this.baseGifCdnUrl = 'https://dl.phncdn.com'; // CDN also gets the HTTPS treatment.
  }

  /**
   * My name is Pornhub, and I am awesome.
   * @returns {string} 'Pornhub'
   */
  get name() {
    return 'Pornhub';
  }

  /**
   * Pornhub likes to start its page count at 1, like a normal website.
   * @returns {number} 1
   */
  get firstpage() {
    return 1;
  }

  /**
   * Builds the Pornhub video search URL.
   * @param {number} [page] - Page number. If you're lazy, I'll use the first.
   * @returns {string} The URL to hit for videos.
   * @throws {Error} If you give me a bogus page number.
   */
  videoUrl(page) {
    const pageNumber = (page !== undefined && Number.isInteger(page) && page >= this.firstpage) ? page : this.firstpage;

    if (pageNumber < this.firstpage) { // Ensure it's not less than our defined first page
      throw new Error(`WTF? Page number for ${this.name} videos (${pageNumber}) can't be less than ${this.firstpage}.`);
    }
    // Assuming this.query is the raw query string.
    return `${this.baseUrl}/video/search?search=${encodeURIComponent(this.query)}&page=${pageNumber}`;
  }

  /**
   * Builds the Pornhub GIF search URL.
   * @param {number} [page] - Page number, same deal as videos.
   * @returns {string} The URL to hit for GIFs.
   * @throws {Error} Bogus page number? You know the drill.
   */
  gifUrl(page) {
    const pageNumber = (page !== undefined && Number.isInteger(page) && page >= this.firstpage) ? page : this.firstpage;

    if (pageNumber < this.firstpage) {
      throw new Error(`Seriously? Page number for ${this.name} GIFs (${pageNumber}) must be ${this.firstpage} or more.`);
    }
    return `${this.baseUrl}/gifs/search?search=${encodeURIComponent(this.query)}&page=${pageNumber}`;
  }

  /**
   * Rips through Pornhub's video search page HTML and extracts the gold.
   * @param {CheerioAPI} $ - Your trusty Cheerio instance, loaded with HTML.
   * @returns {VideoResult[]} Array of video treasures.
   */
  videoParser($) {
    if (typeof $ !== 'function' || typeof $.root !== 'function') { // Basic Cheerio check
      console.error(`[${this.name}] Video parser needs a valid Cheerio instance, genius! What did you pass me?`);
      return [];
    }
    const results = [];
    try {
      // Pornhub's video items usually have this class, but let's be a bit more specific.
      $('ul.videos.search-video-thumbs li.pcVideoListItem[data-id]').each((_, el) => {
        const element = $(el);
        const linkElement = element.find('a.linkVideoThumb').first(); // More specific link
        const thumbImgElement = element.find('img.thumb'); // More specific img
        const durationElement = element.find('.duration');
        const titleElement = element.find('span.title a').first(); // Title is often in its own span a

        const title = titleElement.attr('title')?.trim() || titleElement.text()?.trim() || linkElement.attr('title')?.trim();
        const href = linkElement.attr('href');
        const duration = durationElement.text()?.trim();
        // Try multiple attributes for thumbnails, PH changes stuff. data-src is common for lazy loading.
        let rawThumb = thumbImgElement.attr('data-mediumthumb') || thumbImgElement.attr('data-src') || thumbImgElement.attr('src');

        if (title && href && duration && rawThumb) {
          const cleanedThumb = rawThumb.replace(/\([^)]*\)/g, '').trim(); // Strip (123x456)
          if (cleanedThumb) { // Make sure it's not empty after cleaning
            results.push({
              title,
              url: href.startsWith('http') ? href : `${this.baseUrl}${href}`,
              duration,
              thumb: cleanedThumb.startsWith('//') ? `https:${cleanedThumb}` : (cleanedThumb.startsWith('http') ? cleanedThumb : `${this.baseUrl}${cleanedThumb}`), // Ensure full https URL
              source: this.name,
            });
          } else {
            // console.warn(`[${this.name}] Video skipped: Cleaned thumb was empty. Original: ${rawThumb}`);
          }
        } else {
          // console.warn(`[${this.name}] Video skipped: Missing data. T: ${title}, H: ${href}, D: ${duration}, Th: ${rawThumb}`);
        }
      });
    } catch (error) {
      console.error(`[${this.name}] Oh shit! Video parsing exploded:`, error.message);
    }
    return results;
  }

  /**
   * Shreds Pornhub's GIF page HTML for those sweet, sweet loops.
   * @param {CheerioAPI} $ - Cheerio, again. Don't forget it.
   * @returns {GifResult[]} Array of GIF delights.
   */
  gifParser($) {
    if (typeof $ !== 'function' || typeof $.root !== 'function') {
      console.error(`[${this.name}] GIF parser also needs a real Cheerio instance. Try again!`);
      return [];
    }
    const results = [];
    try {
      // GIF items often have a distinct class or data attribute.
      $('ul.gifs.gifLink li.gifVideoBlock[data-gif_id]').each((_, el) => {
        const element = $(el);
        const linkElement = element.find('a.linkVideoThumb').first(); // GIF links are similar

        if (!linkElement.length) return; // No link, no GIF.

        const gifIdPath = linkElement.attr('href'); // e.g., /view_video.php?viewkey=phGIFID or /gif/123456
        const webmSource = element.find('video[data-webm]').attr('data-webm'); // Direct attribute
        const title = element.find('span.title a').text()?.trim() || linkElement.attr('data-gif_title')?.trim() || "Untitled GIF"; // Robust title finding

        if (gifIdPath && webmSource && title) {
          // Constructing direct GIF URL - Pornhub's CDN URLs can be specific.
          // The original `http://dl.phncdn.com${gifIdPath}.gif` implies `gifIdPath` is exactly what's needed.
          // This can be tricky if `gifIdPath` is like `/view_video.php?viewkey=ID`.
          // A more robust way might involve extracting the actual ID if necessary.
          // For now, let's stick to the pattern that *if* `gifIdPath` is just the ID part it works.
          // If `gifIdPath` is like `/view_video.php?viewkey=ph123`, then `${this.baseGifCdnUrl}/ph123.gif` might be a pattern.
          // The simplest assumption based on original code:
          let directGifSegment = gifIdPath;
          if (gifIdPath.includes("viewkey=")) {
            const keyMatch = gifIdPath.match(/viewkey=([^&]+)/);
            if (keyMatch && keyMatch[1]) directGifSegment = `/${keyMatch[1]}`; // Prepend / if it's just the ID
          }
          // If gifIdPath is already like /ID.gif or /path/to/ID, it might work.
          // This is highly dependent on the exact format of href and what dl.phncdn.com expects.
          // The most reliable method for phncdn is usually based on the actual video key (phXXXXXXXXX).

          results.push({
            title,
            url: `${this.baseGifCdnUrl}${directGifSegment}.gif`, // This is an assumption based on common patterns
            webm: webmSource.startsWith('//') ? `https:${webmSource}` : (webmSource.startsWith('http') ? webmSource : `${this.baseUrl}${webmSource}`), // Ensure full HTTPS URL
            source: this.name,
          });
        } else {
          // console.warn(`[${this.name}] GIF skipped: Missing data. P: ${gifIdPath}, W: ${webmSource}, T: ${title}`);
        }
      });
    } catch (error) {
      console.error(`[${this.name}] Crap! GIF parsing went sideways:`, error.message);
    }
    return results;
  }
}

module.exports = Pornhub;
EOF

# --- Create frontend HTML file ---
info "Creating $FRONTEND_HTML_FILE..."
cat << 'EOF' > "$FRONTEND_HTML_FILE"
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Search - Search Interface</title> <!-- Consider making title more specific if possible -->
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Color Palette */
            --neon-pink: #ff00ff;
            --neon-cyan: #00ffff;
            --dark-bg-start: #1a1a2e;
            --dark-bg-end: #16213e;
            --input-bg: #0f172a;
            --text-color: #e0e0e0;
            --card-bg: rgba(0, 0, 0, 0.6);
            --modal-bg: rgba(0, 0, 0, 0.9);
            --error-bg: rgba(255, 0, 0, 0.8);
            --error-border: #ff4d4d;
            --disabled-opacity: 0.6;
            --focus-outline-color: var(--neon-cyan); /* Added for consistency */
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: var(--input-bg); }
        ::-webkit-scrollbar-thumb { background: var(--neon-pink); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #ff77ff; }

        body {
            background: linear-gradient(135deg, var(--dark-bg-start) 0%, var(--dark-bg-end) 100%);
            color: var(--text-color);
            font-family: 'Roboto', sans-serif;
            margin: 0;
            padding: 0;
            overflow-x: hidden; /* Prevent horizontal scroll */
            scrollbar-color: var(--neon-pink) var(--input-bg); /* Firefox scrollbar */
            scrollbar-width: thin; /* Firefox scrollbar */
        }

        /* Search Container */
        .search-container {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--neon-pink);
            box-shadow: 0 0 20px var(--neon-pink), 0 0 40px var(--neon-cyan), inset 0 0 10px rgba(255, 0, 255, 0.3);
            border-radius: 12px;
        }

        /* Inputs & Select */
        .input-neon, .select-neon {
            background: var(--input-bg);
            color: var(--text-color);
            transition: box-shadow 0.3s ease, border-color 0.3s ease, opacity 0.3s ease;
            appearance: none; /* Remove default styling */
            background-repeat: no-repeat;
            background-position: right 0.75rem center;
            background-size: 0.8em;
            padding-right: 2.5rem; /* Space for custom arrow */
            line-height: 1.5;
            border-radius: 0.5rem; /* Match Tailwind rounded-lg */
        }
        .input-neon {
            border: 2px solid var(--neon-cyan);
            box-shadow: 0 0 10px var(--neon-cyan);
        }
        .input-neon:focus {
            box-shadow: 0 0 20px var(--neon-cyan), 0 0 30px var(--neon-cyan);
            outline: 2px solid transparent; /* Remove default outline */
            outline-offset: 2px;
            border-color: #40e0d0; /* Lighter cyan on focus */
        }
        .select-neon {
            border: 2px solid var(--neon-pink);
            box-shadow: 0 0 10px var(--neon-pink);
            /* Custom arrow using SVG */
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='%23ff00ff'%3E%3Cpath fill-rule='evenodd' d='M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z' clip-rule='evenodd'/%3E%3C/svg%3E");
        }
        .select-neon:focus {
            box-shadow: 0 0 20px var(--neon-pink), 0 0 30px var(--neon-pink);
            outline: 2px solid transparent; /* Remove default outline */
            outline-offset: 2px;
            border-color: #ff77ff; /* Lighter pink on focus */
        }
        .input-neon:disabled, .select-neon:disabled {
            cursor: not-allowed;
            opacity: var(--disabled-opacity);
            box-shadow: none;
        }

        /* Buttons */
        .btn-neon {
            background: linear-gradient(45deg, var(--neon-pink), var(--neon-cyan));
            border: none;
            color: #ffffff; /* Ensure contrast */
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 15px var(--neon-pink), 0 0 30px var(--neon-cyan);
            transition: transform 0.2s ease, box-shadow 0.3s ease, background 0.3s ease, opacity 0.3s ease;
            position: relative;
            overflow: hidden;
            border-radius: 0.5rem; /* Match Tailwind rounded-lg */
        }
        .btn-neon:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 0 25px var(--neon-pink), 0 0 50px var(--neon-cyan);
        }
        .btn-neon:active:not(:disabled) {
            transform: scale(0.98);
            box-shadow: 0 0 10px var(--neon-pink), 0 0 20px var(--neon-cyan);
        }
        .btn-neon:focus-visible { /* Enhanced focus style */
            outline: 2px solid var(--focus-outline-color);
            outline-offset: 2px;
            box-shadow: 0 0 25px var(--neon-pink), 0 0 50px var(--neon-cyan);
        }
        .btn-neon:disabled {
            cursor: not-allowed;
            opacity: var(--disabled-opacity);
            box-shadow: none;
            background: linear-gradient(45deg, #800080, #008080); /* Darker disabled state */
        }
        .btn-neon .spinner {
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #fff;
            width: 16px;
            height: 16px;
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Result Cards */
        .card {
            background: var(--card-bg);
            border: 2px solid var(--neon-cyan);
            box-shadow: 0 0 15px var(--neon-cyan), 0 0 30px var(--neon-pink);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            overflow: hidden;
            cursor: pointer;
            height: 300px; /* Fixed height - ensures grid alignment but may clip content */
            display: flex;
            flex-direction: column;
            border-radius: 8px;
        }
        .card:hover, .card:focus-visible { /* Style focus like hover for accessibility */
            transform: translateY(-5px);
            box-shadow: 0 0 25px var(--neon-cyan), 0 0 50px var(--neon-pink);
            outline: 2px solid transparent; /* Use box-shadow for focus indication */
            outline-offset: 2px;
        }
        .card-media-container {
            height: 200px; /* Fixed height for media area */
            background-color: var(--input-bg); /* Placeholder bg */
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0; /* Prevent shrinking */
            position: relative; /* Needed for absolute positioning of children */
            overflow: hidden;
        }
        /* Common styles for img/video */
        .card-media-container img,
        .card-media-container video {
            width: 100%;
            height: 100%;
            object-fit: cover; /* Cover the container */
            display: block;
            background-color: #000; /* Background during load */
        }
        /* Specific styles for video preview */
        .card-media-container img.video-thumb, /* Classify video thumbs */
        .card-media-container video.preview-video {
            position: absolute; /* Position video and thumb to overlap */
            top: 0;
            left: 0;
            transition: opacity 0.3s ease-in-out; /* Smooth transition */
        }
        .card-media-container video.preview-video {
            opacity: 0;
            pointer-events: none; /* Prevent interaction when hidden */
            z-index: 5;
        }
        .card-media-container:hover video.preview-video,
        .card:focus-within .card-media-container video.preview-video { /* Play on focus as well */
            opacity: 1;
            pointer-events: auto;
        }
        .card-media-container img.video-thumb {
            opacity: 1;
            z-index: 1;
        }
        /* GIF images are not absolutely positioned */
        .card-media-container img.gif-image {
            position: static; /* Let it behave normally */
        }

        .card-info {
            height: 100px; /* Fixed height for info area */
            display: flex;
            flex-direction: column;
            justify-content: space-between; /* Push link down */
            padding: 0.75rem;
            flex-grow: 1; /* Allow growing if needed, though height is fixed */
            overflow: hidden;
        }
        .card-title {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 0.25rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap; /* Prevent wrapping */
            text-shadow: 0 0 5px var(--neon-cyan);
        }
        .card-link {
             color: var(--neon-cyan);
             text-shadow: 0 0 5px var(--neon-pink);
             font-size: 0.875rem;
             transition: color 0.2s ease;
             align-self: flex-start;
             margin-top: auto; /* Push to bottom */
             text-decoration: none;
        }
        .card-link:hover, .card-link:focus {
             color: #7fffd4; /* Lighter cyan */
             text-decoration: underline;
             outline: none; /* Handled by parent card focus */
        }
        .media-error-placeholder {
             color: #aaa;
             text-align: center;
             padding: 10px;
             font-size: 0.9em;
             width: 100%;
             height: 100%;
             display: flex;
             align-items: center;
             justify-content: center;
             position: relative; /* Ensure it's positioned correctly */
             z-index: 1;
        }
        .duration-overlay {
            position: absolute;
            bottom: 0.5rem;
            right: 0.5rem;
            background-color: rgba(0, 0, 0, 0.75);
            color: white;
            font-size: 0.75rem;
            padding: 0.125rem 0.5rem;
            border-radius: 4px;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
            pointer-events: none; /* Don't interfere with hover */
            z-index: 10; /* Above image and video */
        }

        /* Modal */
        .modal {
            position: fixed;
            inset: 0;
            background: var(--modal-bg);
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            /* Transition properties */
            visibility: hidden;
            opacity: 0;
            transition: visibility 0s linear 0.3s, opacity 0.3s ease;
        }
        .modal.is-open {
            visibility: visible;
            opacity: 1;
            transition: visibility 0s linear 0s, opacity 0.3s ease;
        }
        .modal-container {
            position: relative;
            background: var(--input-bg);
            border: 3px solid var(--neon-pink);
            box-shadow: 0 0 30px var(--neon-pink), 0 0 60px var(--neon-cyan);
            max-width: 90vw;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: hidden; /* Contain content */
            border-radius: 8px;
            transform: scale(0.95); /* Start slightly smaller */
            transition: transform 0.3s ease;
        }
        .modal.is-open .modal-container {
            transform: scale(1); /* Scale to full size when open */
        }
        .modal-content {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            max-height: calc(90vh - 80px); /* Adjust based on link container height */
            overflow: hidden; /* Prevent content overflow */
            padding: 1rem;
            position: relative; /* Needed for error placeholder */
        }
        .modal-content img {
            max-width: 100%;
            max-height: 100%;
            display: block;
            object-fit: contain; /* Ensure full image/gif is visible */
            border-radius: 4px;
        }
        .modal-link-container {
            padding: 10px 15px;
            text-align: center;
            background: rgba(0,0,0,0.5);
            width: 100%;
            flex-shrink: 0; /* Prevent shrinking */
            border-top: 1px solid var(--neon-pink);
            min-height: 40px; /* Ensure some space */
            display: flex; /* Center link vertically */
            align-items: center;
            justify-content: center;
        }
        .modal-link {
            color: var(--neon-cyan);
            font-weight: 600;
            text-decoration: none;
            transition: color 0.2s ease;
            word-break: break-all; /* Prevent long URLs from overflowing */
            display: block; /* Ensure it takes full width for centering */
        }
        .modal-link:hover, .modal-link:focus {
             color: #7fffd4; /* Lighter cyan */
             text-decoration: underline;
             outline: none; /* Use default browser focus or custom style */
        }
        .close-button {
            position: absolute;
            top: 8px;
            right: 12px;
            color: var(--neon-cyan);
            font-size: 2rem;
            font-weight: bold;
            text-shadow: 0 0 10px var(--neon-pink);
            cursor: pointer;
            transition: transform 0.2s ease, color 0.2s ease;
            z-index: 1010; /* Above content */
            line-height: 1;
            border: none;
            background: none;
            padding: 0;
        }
        .close-button:hover, .close-button:focus {
            transform: scale(1.2);
            color: var(--neon-pink);
            outline: none; /* Custom styling */
        }
        .close-button:focus-visible { /* Explicit focus style */
             outline: 2px solid var(--focus-outline-color);
             outline-offset: 1px;
        }

        /* Error Message */
        #errorMessage {
            background: var(--error-bg);
            border: 2px solid var(--error-border);
            box-shadow: 0 0 15px #ff0000;
            color: #ffffff;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            word-break: break-word; /* Prevent overflow */
            transition: opacity 0.3s ease, visibility 0.3s ease; /* Match modal transition timing */
            opacity: 0;
            visibility: hidden;
            border-radius: 0.5rem; /* Match inputs */
        }
        #errorMessage:not(.hidden) { /* Use :not(.hidden) to control visibility */
             opacity: 1;
             visibility: visible;
             transition: opacity 0.3s ease, visibility 0s linear 0s; /* Show immediately */
        }

        /* Skeleton Loaders */
        .skeleton-card {
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #333; /* Less prominent border */
            border-radius: 8px;
            overflow: hidden;
            height: 300px; /* Match card height */
            animation: pulse 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite;
            display: flex;
            flex-direction: column;
            padding: 0; /* No padding on skeleton itself */
        }
        .skeleton-img {
            height: 200px; /* Match card media height */
            background-color: #2a2a3e; /* Use a color from the palette */
            flex-shrink: 0;
        }
        .skeleton-info {
            padding: 0.75rem;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            flex-grow: 1;
            height: 100px; /* Match card info height */
        }
        .skeleton-text {
            height: 1rem; /* Match card title approx height */
            background-color: #2a2a3e;
            width: 80%;
            border-radius: 4px;
            margin-bottom: 0.5rem;
        }
        .skeleton-link {
            height: 0.875rem; /* Match card link approx height */
            background-color: #2a2a3e;
            width: 50%;
            border-radius: 4px;
            margin-top: auto; /* Align bottom */
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: .5; }
        }

        /* Utility */
        .hidden { display: none !important; } /* Tailwind often uses !important */

        /* Responsive Design */
        @media (max-width: 640px) {
            h1 { font-size: 2rem; }
            .search-container { padding: 1rem; }

            /* Adjust flex layout for controls on small screens */
            .search-controls {
                flex-direction: column;
                align-items: stretch; /* Make items full width */
            }
            .search-controls > *:not(:last-child) {
                 margin-bottom: 1rem; /* Add space between stacked controls */
                 margin-right: 0; /* Remove horizontal space */
            }
             /* Ensure selects and button take full width */
             .search-controls > select,
             .search-controls > button {
                 width: 100%;
             }

            /* Adjust card sizes */
            .card, .skeleton-card { height: 280px; }
            .card-media-container, .skeleton-img { height: 150px; }
            .card-info, .skeleton-info { height: 130px; padding: 0.5rem; } /* Increased info height */
            .card-title { font-size: 0.9rem; }

            /* Stack pagination controls vertically */
            .pagination-controls {
                flex-direction: column;
                align-items: stretch; /* Full width buttons */
            }
            .pagination-controls button {
                width: 100%;
                margin-bottom: 0.5rem;
            }
            .pagination-controls button:last-of-type {
                 margin-bottom: 0; /* Remove margin from last button */
            }
            .pagination-controls span { /* Page indicator */
                margin-bottom: 0.5rem;
                text-align: center;
                width: 100%;
            }

            /* Adjust modal content/link for smaller screens */
            .modal-content { padding: 0.5rem; max-height: calc(90vh - 70px); }
            .modal-link-container { min-height: 30px; padding: 5px 10px; }
            .modal-link { font-size: 0.9rem; }
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center py-6 px-2">

    <!-- Search Header -->
    <header class="w-full max-w-5xl search-container p-6 sm:p-8 mb-8" role="search" aria-labelledby="search-heading">
        <h1 id="search-heading" class="text-3xl sm:text-4xl font-bold text-center mb-6" style="text-shadow: 0 0 10px var(--neon-pink), 0 0 20px var(--neon-cyan);">
            Neon Search
            <span class="text-lg block font-normal">(Search Interface)</span>
        </h1>
        <!-- Search Controls Container -->
        <div class="search-controls flex flex-col sm:flex-row items-stretch sm:space-x-4 mb-6">
             <input id="searchInput" type="text" placeholder="Enter search query..." aria-label="Search Query" class="input-neon flex-1 p-3 text-base" autocomplete="off">
             <!-- Type Select -->
             <select id="typeSelect" aria-label="Select Search Type" class="select-neon p-3 text-base sm:w-auto">
                 <option value="videos" selected>Videos</option>
                 <option value="gifs">GIFs</option>
             </select>
             <!-- Driver Select -->
             <select id="driverSelect" aria-label="Select Search Provider" class="select-neon p-3 text-base sm:w-auto">
                <option value="pornhub">Pornhub</option>
                <option value="sex">Sex.com</option>
                <option value="redtube" selected>Redtube</option> <!-- Default can be changed -->
                <option value="xvideos">XVideos</option>
                <option value="mock">Mock (Test)</option> <!-- Mock Driver for testing -->
             </select>
            <button id="searchBtn" type="button" class="btn-neon px-6 py-3 font-semibold text-base flex items-center justify-center" aria-controls="results" aria-describedby="errorMessage">
                <span id="searchBtnText">Search</span> <!-- Button Text Span -->
                <span id="loadingIndicator" class="hidden ml-2" aria-hidden="true"><span class="spinner"></span></span>
            </button>
        </div>
        <!-- Error Message Area -->
        <p id="errorMessage" class="text-white text-center p-3 hidden" role="alert" aria-live="assertive"></p>
    </header>

    <!-- Main Content Area (Results) -->
    <main class="w-full max-w-5xl flex-grow">
        <div id="results" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6 px-4" aria-live="polite">
            <!-- Initial message or results go here -->
            <p id="initialMessage" class="text-center text-xl col-span-full text-gray-400" style="text-shadow: 0 0 5px var(--neon-cyan);">Enter a query and select options to search...</p>
        </div>

        <!-- Pagination Controls -->
        <nav id="pagination" class="w-full max-w-5xl mt-8 flex justify-center items-center space-x-4 pagination-controls px-4 hidden" role="navigation" aria-label="Pagination">
             <button id="prevBtn" type="button" aria-label="Previous Page" class="btn-neon px-4 py-2 text-sm font-semibold" disabled>&lt; Previous</button>
             <span id="pageIndicator" class="font-semibold text-lg" style="text-shadow: 0 0 8px var(--neon-cyan);" aria-live="polite">Page 1</span>
             <button id="nextBtn" type="button" aria-label="Next Page" class="btn-neon px-4 py-2 text-sm font-semibold" disabled>Next &gt;</button>
        </nav>
    </main>

    <!-- Media Modal -->
    <div id="mediaModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="modalLinkContainer" tabindex="-1">
         <div class="modal-container">
             <button type="button" class="close-button" title="Close" aria-label="Close Modal"></button>
             <div id="modalContent" class="modal-content">
                 <!-- Modal Image/GIF/Placeholder will be loaded here -->
             </div>
             <div id="modalLinkContainer" class="modal-link-container">
                 <!-- Modal Link will be loaded here -->
             </div>
         </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/axios@1.7.2/dist/axios.min.js" defer></script> <!-- Use defer to load after HTML parsing -->
    <script>
        'use strict';

        // --- Constants ---
        const API_BASE_URL = '/api/search'; // Centralized API endpoint
        const HOVER_PLAY_DELAY_MS = 150; // Delay before playing video on hover/focus
        const HOVER_LEAVE_DELAY_MS = 50; // Delay before pausing video on leave/blur
        const API_TIMEOUT_MS = 25000; // API request timeout in milliseconds
        const SKELETON_COUNT = 9; // Number of skeleton loaders to show

        // --- DOM Element References ---
        const searchInput = document.getElementById('searchInput');
        const typeSelect = document.getElementById('typeSelect');
        const driverSelect = document.getElementById('driverSelect');
        const searchBtn = document.getElementById('searchBtn');
        const searchBtnText = document.getElementById('searchBtnText');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const resultsDiv = document.getElementById('results');
        const initialMessage = document.getElementById('initialMessage');
        const errorMessage = document.getElementById('errorMessage');
        const modal = document.getElementById('mediaModal');
        const modalContent = document.getElementById('modalContent');
        const modalLinkContainer = document.getElementById('modalLinkContainer');
        const closeModalBtn = modal.querySelector('.close-button');
        const paginationControls = document.getElementById('pagination');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const pageIndicator = document.getElementById('pageIndicator');

        // --- Application State ---
        const appState = {
            isLoading: false,
            currentPage: 1,
            currentQuery: '',
            currentDriver: driverSelect.value,
            currentType: typeSelect.value,
            resultsCache: [],
            lastFocusedElement: null, // Store element that opened the modal
            // Heuristic for enabling 'Next' button. Assumes API returns *at least* this many items if more pages exist.
            // This might enable 'Next' on the last page if it returns exactly this number.
            // Ideally, the API provides total results/pages. Updated dynamically based on results.
            maxResultsHeuristic: 18, // Initial default, updated based on API response or mock data size
            hoverPlayTimeout: null, // Timeout ID for delayed video play on hover
            hoverLeaveTimeout: null, // Timeout ID for delayed video pause on leave
        };

        // --- API Communication ---
        /**
         * Fetches search results from the backend API or mock data source.
         * @param {string} query - The search term.
         * @param {string} driver - The selected search provider/driver.
         * @param {string} type - The selected search type ('videos' or 'gifs').
         * @param {number} page - The requested page number.
         * @returns {Promise<{success: boolean, data?: Array<object>, error?: string}>} - Promise resolving to success/data or failure/error.
         */
        async function fetchResultsFromApi(query, driver, type, page) {
            // *** MOCK RESPONSE FOR TESTING ***
            if (driver === 'mock') {
                console.log(`%c[FE] Using Mock Data for ${type}`, 'color: orange');
                await new Promise(resolve => setTimeout(resolve, 500)); // Simulate network delay

                let mockData = [];
                const itemsPerPage = 6; // Define mock pagination size

                if (type === 'videos') {
                     mockData = [
                        { title: "Mock Video 1 (Preview)", url: "#vid1", thumbnail: "https://via.placeholder.com/640x360/ff00ff/fff?text=Vid+Thumb+1", image_hq: "https://via.placeholder.com/1280x720/ff00ff/fff?text=Vid+HQ+1", preview_video: "https://test-videos.co.uk/vids/bigbuckbunny/mp4/h264/360/Big_Buck_Bunny_360_10s_1MB.mp4", duration: "0:10" },
                        { title: "Mock Video 2 (No Preview)", url: "#vid2", thumbnail: "https://via.placeholder.com/640x360/00ffff/000?text=Vid+Thumb+2", duration: "1:00" },
                        { title: "Mock Video 3 (Broken Thumb)", url: "#vid3", thumbnail: "https://invalid.url/thumb.jpg", preview_video: "https://test-videos.co.uk/vids/bigbuckbunny/mp4/h264/360/Big_Buck_Bunny_360_10s_1MB.mp4", duration: "0:12" },
                        { title: "Mock Video 4 (No Media)", url: "#vid4", duration: "0:30" },
                        { title: "Mock Video 5 (Long Title That Might Wrap Or Get Cut Off Depending on Viewport)", url: "#vid5", thumbnail: "https://via.placeholder.com/640x360/ffaa00/fff?text=Vid+Thumb+5", duration: "5:00" },
                        { title: "Mock Video 6", url: "#vid6", thumbnail: "https://via.placeholder.com/640x360/00aaff/fff?text=Vid+Thumb+6", duration: "0:15" },
                        { title: "Mock Video 7 (Page 2)", url: "#vid7", thumbnail: "https://via.placeholder.com/640x360/aa00ff/fff?text=Vid+Thumb+7", duration: "2:30" },
                    ];
                } else if (type === 'gifs') {
                     mockData = [
                        { title: "Mock GIF 1", url: "https://media.tenor.com/gGQVLAlItnkAAAAC/cat-what.gif" }, // Direct GIF URL
                        { title: "Mock GIF 2", url: "https://media.tenor.com/g13_ym1KMWAAAAAC/cat-typing.gif" },
                        { title: "Mock GIF 3 (WebM Example - Note: Display not implemented)", url: "https://via.placeholder.com/300x200/00ff00/000?text=GIF+Thumb+3", webm: "https://sample-videos.com/video123/webm/720/big_buck_bunny_720p_1mb.webm" },
                        { title: "Mock GIF 4 (Broken URL)", url: "https://invalid.url/image.gif" },
                        { title: "Mock GIF 5", url: "https://media.tenor.com/vjZZE3bXhKcAAAAC/cats-animals.gif" },
                        { title: "Mock GIF 6", url: "https://media.tenor.com/h9c7u4dYm3QAAAAC/cat-computer.gif" },
                        { title: "Mock GIF 7 (Page 2)", url: "https://media.tenor.com/81f5t1LJp7UAAAAC/cat-working.gif" },
                    ];
                }

                // Simulate pagination
                const start = (page - 1) * itemsPerPage;
                const end = start + itemsPerPage;
                const paginatedData = mockData.slice(start, end);
                appState.maxResultsHeuristic = itemsPerPage; // Update heuristic based on mock page size
                return { success: true, data: paginatedData };
            }
            // *** END MOCK RESPONSE ***

            // --- Real API Call ---
            const params = { query, driver, type, page }; // Pass all necessary params
            console.log(`%c[FE] -> API Request: ${API_BASE_URL}`, 'color: cyan', params);

            try {
                const response = await axios.get(API_BASE_URL, { params, timeout: API_TIMEOUT_MS });
                // Ensure data is always an array, even if API returns null or something else on no results
                const data = Array.isArray(response.data) ? response.data : [];
                // Update heuristic based on actual results count, min of 10
                appState.maxResultsHeuristic = data.length > 0 ? Math.max(data.length, 10) : 10;
                console.log(`%c[FE] <- API Success (${response.status}): ${data.length} ${type} results received. Max heuristic: ${appState.maxResultsHeuristic}`, 'color: lightgreen');
                return { success: true, data: data };
            } catch (error) {
                console.error('[FE] <- API Error:', error);
                let message = 'An unexpected error occurred while fetching results.';
                if (error.code === 'ECONNABORTED' || (error.message && error.message.includes('timeout'))) {
                    message = `API request timed out after ${API_TIMEOUT_MS / 1000} seconds. The server might be busy or unavailable.`;
                } else if (error.response) {
                    // Try to get error message from backend response, fallback to status
                    const apiErrorMsg = error.response.data?.error || `Server responded with status ${error.response.status}`;
                    message = `API Error: ${apiErrorMsg}`;
                } else if (error.request) {
                    // Request was made but no response received
                    message = 'Network Error: Could not connect to the backend API. Is the server running?';
                } else {
                    // Setup error or other frontend issue
                    message = `Frontend Error: ${error.message}`;
                }
                return { success: false, error: message };
            }
        }

        // --- UI Manipulation ---

        /** Displays an error message to the user. */
        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.classList.remove('hidden');
            errorMessage.setAttribute('aria-hidden', 'false');
            resultsDiv.innerHTML = ''; // Clear any existing results or skeletons
            initialMessage?.classList.add('hidden'); // Hide initial message
            paginationControls.classList.add('hidden'); // Hide pagination
            console.warn(`%c[FE] Displaying Error: ${message}`, 'color: orange');
        }

        /** Hides the error message area. */
        function hideError() {
            if (!errorMessage.classList.contains('hidden')) {
                errorMessage.classList.add('hidden');
                errorMessage.setAttribute('aria-hidden', 'true');
                errorMessage.textContent = ''; // Clear text for screen readers
            }
        }

        /** Displays skeleton loader cards while results are loading. */
        function showSkeletons(count = SKELETON_COUNT) {
            resultsDiv.innerHTML = ''; // Clear previous content
            initialMessage?.classList.add('hidden'); // Hide initial message
            resultsDiv.setAttribute('aria-busy', 'true'); // Indicate loading state
            console.log(`%c[FE] Displaying ${count} skeleton loaders...`, 'color: gray');
            const fragment = document.createDocumentFragment(); // Use fragment for performance
            for (let i = 0; i < count; i++) {
                const skeleton = document.createElement('div');
                skeleton.className = 'skeleton-card';
                skeleton.setAttribute('aria-hidden', 'true'); // Hide from screen readers
                skeleton.innerHTML = `
                    <div class="skeleton-img"></div>
                    <div class="skeleton-info">
                        <div class="skeleton-text"></div>
                        <div class="skeleton-link"></div>
                    </div>`;
                fragment.appendChild(skeleton);
            }
            resultsDiv.appendChild(fragment);
            paginationControls.classList.add('hidden'); // Hide pagination during load
        }

        /** Updates the UI state (disabling/enabling inputs, showing/hiding loader). */
        function setSearchState(loading) {
            appState.isLoading = loading;
            searchInput.disabled = loading;
            typeSelect.disabled = loading; // Disable type select during load
            driverSelect.disabled = loading;
            searchBtn.disabled = loading;
            resultsDiv.setAttribute('aria-busy', loading ? 'true' : 'false');

            // Always disable pagination buttons when loading starts
            prevBtn.disabled = true;
            nextBtn.disabled = true;

            if (loading) {
                searchBtnText.textContent = 'Searching...';
                loadingIndicator.classList.remove('hidden');
                loadingIndicator.setAttribute('aria-hidden', 'false');
                showSkeletons(); // Show skeletons when loading starts
            } else {
                searchBtnText.textContent = 'Search';
                loadingIndicator.classList.add('hidden');
                loadingIndicator.setAttribute('aria-hidden', 'true');
                // Re-enable inputs only if not loading
                searchInput.disabled = false;
                typeSelect.disabled = false;
                driverSelect.disabled = false;
                searchBtn.disabled = false;
                // Pagination buttons will be updated by updatePaginationButtons() after results
            }
        }

        /** Updates the visibility and state of pagination buttons based on current state. */
        function updatePaginationButtons() {
             // Hide pagination if loading or if an error is currently displayed
            if (appState.isLoading || !errorMessage.classList.contains('hidden')) {
                 paginationControls.classList.add('hidden');
                 return;
            }

            const hasResults = appState.resultsCache.length > 0;
            // Enable 'Next' if we received results equal to or more than the heuristic suggests a full page.
            // This is an *assumption* about the API behavior.
            const likelyMorePages = hasResults && appState.resultsCache.length >= appState.maxResultsHeuristic;
            // Show pagination if we have results OR if we are on a page > 1 (even if page > 1 has no results)
            const showPagination = hasResults || appState.currentPage > 1;

            paginationControls.classList.toggle('hidden', !showPagination);

            if (showPagination) {
                prevBtn.disabled = appState.currentPage <= 1;
                nextBtn.disabled = !likelyMorePages; // Disable if we likely don't have more pages
                pageIndicator.textContent = `Page ${appState.currentPage}`;
                pageIndicator.setAttribute('aria-label', `Current page, Page ${appState.currentPage}`);
            }
        }

        /** Renders a placeholder message within a media container (e.g., for broken images/videos). */
        function renderMediaErrorPlaceholder(container, text) {
             // Avoid adding multiple placeholders
             if (container.querySelector('.media-error-placeholder')) return;

             const errorPlaceholder = document.createElement('p');
             errorPlaceholder.className = 'media-error-placeholder';
             errorPlaceholder.textContent = text;
             container.innerHTML = ''; // Clear potentially broken elements first
             container.appendChild(errorPlaceholder);
        }

        /**
         * Creates the media container (image/video/placeholder) for a result card.
         * @param {object} item - The search result item.
         * @returns {HTMLDivElement} The configured media container element.
         */
        function createMediaContainer(item) {
            const mediaContainer = document.createElement('div');
            mediaContainer.className = 'card-media-container';
            const titleText = item.title || (appState.currentType === 'gifs' ? 'Untitled GIF' : 'Untitled Video');
            mediaContainer.setAttribute('role', 'figure'); // Semantically a figure
            mediaContainer.setAttribute('aria-label', `Preview for ${titleText}`);

            // --- Handle Videos ---
            if (appState.currentType === 'videos') {
                const thumbnailUrl = item.thumbnail || item.thumb; // Accept either key
                const previewVideoUrl = item.preview_video;
                let hasRenderedImage = false;
                let hasRenderedVideo = false;

                // Create image element (acts as poster and fallback)
                if (thumbnailUrl) {
                    const img = document.createElement('img');
                    img.src = thumbnailUrl;
                    img.alt = ''; // Decorative, alt text is on the figure/card
                    img.loading = 'lazy'; // Lazy load card images
                    img.width = 300; // Provide layout hints
                    img.height = 200;
                    img.className = 'video-thumb'; // Class for styling overlap
                    img.onerror = () => {
                        console.warn(`%c[FE] Video thumbnail load failed: ${thumbnailUrl}`, 'color: orange');
                        img.remove(); // Remove broken image
                        hasRenderedImage = false;
                        // If video also fails or doesn't exist, show placeholder
                        if (!hasRenderedVideo && !mediaContainer.querySelector('.media-error-placeholder')) {
                             renderMediaErrorPlaceholder(mediaContainer, 'Preview Unavailable');
                        }
                    };
                    mediaContainer.appendChild(img);
                    hasRenderedImage = true;
                }

                // Create video element if preview URL exists
                if (previewVideoUrl) {
                    const video = document.createElement('video');
                    video.src = previewVideoUrl;
                    // Use thumbnail as poster if available
                    if (hasRenderedImage && mediaContainer.querySelector('img.video-thumb')) {
                        video.poster = thumbnailUrl;
                    }
                    video.width = 300; video.height = 200; // Layout hints
                    video.muted = true; video.loop = true; // Standard preview attributes
                    video.playsInline = true; // Important for mobile
                    video.preload = 'metadata'; // Load enough to get dimensions/duration
                    video.className = 'preview-video';
                    video.onerror = (e) => {
                        console.warn(`%c[FE] Preview video load failed: ${previewVideoUrl}`, 'color: orange', e);
                        video.remove();
                        hasRenderedVideo = false;
                        // If image also failed or doesn't exist, show placeholder
                        if (!hasRenderedImage && !mediaContainer.querySelector('.media-error-placeholder')) {
                            renderMediaErrorPlaceholder(mediaContainer, 'Preview Unavailable');
                        }
                    };
                    // Insert video before image if image exists, otherwise just append
                    const firstChild = mediaContainer.firstChild;
                    if (firstChild) { mediaContainer.insertBefore(video, firstChild); }
                    else { mediaContainer.appendChild(video); }
                    hasRenderedVideo = true;
                }

                // If neither image nor video could be rendered, show placeholder
                if (!hasRenderedImage && !hasRenderedVideo && !mediaContainer.querySelector('.media-error-placeholder')) {
                     renderMediaErrorPlaceholder(mediaContainer, 'No Preview Available');
                }

                // Add duration overlay for videos only
                if (item.duration) {
                    const durationOverlay = document.createElement('span');
                    durationOverlay.className = 'duration-overlay';
                    durationOverlay.textContent = item.duration;
                    durationOverlay.setAttribute('aria-hidden', 'true'); // Decorative
                    mediaContainer.appendChild(durationOverlay);
                }
            }
            // --- Handle GIFs ---
            else if (appState.currentType === 'gifs') {
                const gifUrl = item.url; // GIF URL is expected in 'url' field
                if (gifUrl) {
                    const img = document.createElement('img');
                    img.src = gifUrl;
                    img.alt = ''; // Decorative, alt text is on the figure/card
                    img.loading = 'lazy';
                    img.width = 300; // Layout hints
                    img.height = 200;
                    img.className = 'gif-image'; // Classify for potential specific styling
                    img.onerror = () => {
                        console.warn(`%c[FE] GIF load failed: ${gifUrl}`, 'color: orange');
                        renderMediaErrorPlaceholder(mediaContainer, 'GIF Unavailable');
                    };
                    mediaContainer.appendChild(img);
                } else {
                    // No GIF URL provided
                    renderMediaErrorPlaceholder(mediaContainer, 'No GIF Available');
                }
                // No duration or video preview logic for GIFs
            }

            return mediaContainer;
        }

        /**
         * Displays search results in the grid or shows a 'no results' message.
         * @param {Array<object>} items - Array of result objects from the API.
         */
        function displaySearchResults(items) {
            resultsDiv.innerHTML = ''; // Clear previous results/skeletons
            initialMessage?.classList.add('hidden'); // Ensure initial message is hidden
            resultsDiv.removeAttribute('aria-busy'); // Not busy anymore
            appState.resultsCache = items || []; // Store results, ensure it's an array

            console.log(`%c[FE] Displaying ${appState.resultsCache.length} ${appState.currentType} results.`, 'color: lightgreen');

            if (appState.resultsCache.length === 0) {
                const noResults = document.createElement('p');
                noResults.className = 'text-center text-lg col-span-full p-4';
                noResults.style.textShadow = '0 0 10px var(--neon-pink)';
                // More specific "No results" message
                noResults.textContent = `No ${appState.currentType} found for "${appState.currentQuery}" on page ${appState.currentPage} via ${appState.currentDriver}.`;
                resultsDiv.appendChild(noResults);
            } else {
                const fragment = document.createDocumentFragment(); // Use fragment for performance
                appState.resultsCache.forEach(item => {
                    const card = document.createElement('div');
                    card.className = 'card';

                    // Create media container (handles video/gif/errors internally)
                    const mediaContainer = createMediaContainer(item);

                    // Create info container
                    const infoContainer = document.createElement('div');
                    infoContainer.className = 'card-info';

                    const title = document.createElement('h3');
                    title.className = 'card-title';
                    const titleText = item.title || (appState.currentType === 'gifs' ? 'Untitled GIF' : 'Untitled Video');
                    title.textContent = titleText;
                    title.title = titleText; // Tooltip for potentially truncated titles
                    infoContainer.appendChild(title);

                    const link = document.createElement('a');
                    link.href = item.url || '#'; // For videos: source page; For GIFs: direct GIF URL
                    link.target = '_blank'; // Open in new tab
                    link.rel = 'noopener noreferrer'; // Security best practice
                    link.className = 'card-link';
                    // Adjust link text based on type
                    link.textContent = appState.currentType === 'gifs' ? 'View GIF' : 'View Source';
                    const arrowSpan = document.createElement('span');
                    arrowSpan.setAttribute('aria-hidden', 'true');
                    arrowSpan.innerHTML = ' &rarr;'; // Visual cue
                    link.appendChild(arrowSpan);
                    // Prevent card click when clicking the link itself
                    link.onclick = (e) => e.stopPropagation();
                    infoContainer.appendChild(link);

                    card.appendChild(mediaContainer);
                    card.appendChild(infoContainer);

                    // Make card focusable and interactive
                    card.setAttribute('tabindex', '0');
                    card.setAttribute('role', 'button');
                    card.setAttribute('aria-label', `View details for ${titleText}`);

                    // Event listeners for opening the modal
                    card.addEventListener('click', () => openModal(item, card));
                    card.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' || e.key === ' ') { // Space or Enter activates
                            e.preventDefault(); // Prevent page scroll on Space
                            openModal(item, card);
                        }
                    });

                    // --- Add Hover/Focus Listeners ONLY for Video Previews ---
                    if (appState.currentType === 'videos') {
                        const videoPreview = mediaContainer.querySelector('video.preview-video');
                        if (videoPreview) {
                            const playVideo = () => {
                                videoPreview.play().catch(e => {
                                    // Ignore AbortError which can happen if play is interrupted quickly
                                    if (e.name !== 'AbortError') {
                                        console.warn('[FE] Video play failed:', e.name, e.message);
                                    }
                                });
                            };
                            const pauseVideo = () => {
                                videoPreview.pause();
                                // Reset video to start only if it has loaded metadata
                                if (videoPreview.readyState > 0) videoPreview.currentTime = 0;
                            };

                            // Play on hover/focus (with delay)
                            const handleMouseEnterFocus = () => {
                                clearTimeout(appState.hoverLeaveTimeout); // Cancel any pending pause
                                // Debounce play action
                                appState.hoverPlayTimeout = setTimeout(playVideo, HOVER_PLAY_DELAY_MS);
                            };
                            // Pause on leave/blur (with delay)
                            const handleMouseLeaveBlur = () => {
                                clearTimeout(appState.hoverPlayTimeout); // Cancel any pending play
                                // Debounce pause action
                                appState.hoverLeaveTimeout = setTimeout(pauseVideo, HOVER_LEAVE_DELAY_MS);
                            };

                            mediaContainer.addEventListener('mouseenter', handleMouseEnterFocus);
                            card.addEventListener('focusin', handleMouseEnterFocus); // Use focusin to capture focus on card itself

                            mediaContainer.addEventListener('mouseleave', handleMouseLeaveBlur);
                            card.addEventListener('focusout', (e) => {
                                // Only pause if focus moves *outside* the card entirely
                                if (!card.contains(e.relatedTarget)) {
                                    handleMouseLeaveBlur();
                                }
                            });
                        }
                    } // --- End Video Hover/Focus Listeners ---

                    fragment.appendChild(card);
                });
                resultsDiv.appendChild(fragment);
            }
            updatePaginationButtons(items.length); // Update pagination based on new results
        }

        // --- Modal Handling ---

        /** Opens the modal, adapting content for Videos or GIFs. */
        function openModal(itemData, triggerElement) {
            const itemType = appState.currentType; // Use current state type
            const titleText = itemData.title || (itemType === 'gifs' ? 'Untitled GIF' : 'Untitled Video');
            console.log(`%c[FE] Opening modal for ${itemType}: ${titleText}`, 'color: magenta');

            // Store the element that triggered the modal for focus return
            appState.lastFocusedElement = triggerElement || document.activeElement;

            modalContent.innerHTML = ''; // Clear previous modal content
            modalLinkContainer.innerHTML = ''; // Clear previous modal link

            // --- Modal Content (Image/GIF) ---
            let displayUrl = null;
            let isGif = itemType === 'gifs';

            if (isGif) {
                displayUrl = itemData.url; // Use direct GIF url
            } else { // It's a video
                // Prefer HQ image if available, fallback to thumbnail
                const thumbnailUrl = itemData.thumbnail || itemData.thumb;
                displayUrl = itemData.image_hq || thumbnailUrl;
            }

            if (displayUrl) {
                const modalImg = document.createElement('img');
                modalImg.src = displayUrl;
                modalImg.alt = `Preview for ${titleText}`; // Alt text for the image itself
                modalImg.loading = 'eager'; // Load modal content eagerly
                modalImg.onerror = () => {
                    console.warn(`%c[FE] Modal ${isGif ? 'GIF' : 'image'} load failed: ${displayUrl}`, 'color: orange');
                    // Simple fallback message inside the modal content area
                    renderMediaErrorPlaceholder(modalContent, `${isGif ? 'GIF' : 'Preview Image'} Failed to Load`);
                    // Make placeholder text more visible in modal
                    const placeholder = modalContent.querySelector('.media-error-placeholder');
                    if(placeholder) placeholder.style.color = 'white';
                };
                modalContent.appendChild(modalImg);
            } else {
                // Render placeholder if no display URL is available at all
                renderMediaErrorPlaceholder(modalContent, `${isGif ? 'GIF' : 'Preview Image'} Not Available`);
                const placeholder = modalContent.querySelector('.media-error-placeholder');
                if(placeholder) placeholder.style.color = 'white';
            }

            // --- Modal Link ---
            const modalLink = document.createElement('a');
            modalLink.href = itemData.url || '#'; // Video source page or GIF URL
            modalLink.target = '_blank';
            modalLink.rel = 'noopener noreferrer'; // Security best practice
            modalLink.className = 'modal-link';
            // Adjust link text and make it descriptive
            modalLink.textContent = isGif ? `View GIF Source: "${titleText}"` : `View Video Source: "${titleText}"`;
            modalLinkContainer.appendChild(modalLink);

            // Set aria-labelledby to the container holding the descriptive link
            modal.setAttribute('aria-labelledby', 'modalLinkContainer');

            // Show modal and manage focus
            modal.classList.add('is-open');
            // Move focus to the close button after the modal transition likely finishes
            requestAnimationFrame(() => {
                setTimeout(() => closeModalBtn.focus(), 50); // Small delay might help ensure focus works
            });
        }

        /** Closes the media modal and returns focus to the triggering element. */
        function closeModal() {
            if (!modal.classList.contains('is-open')) return; // Prevent closing if already closed

            console.log('%c[FE] Closing modal.', 'color: magenta');
            modal.classList.remove('is-open');

            // Delay clearing content until after fade-out transition (300ms)
            setTimeout(() => {
                // Double check it wasn't immediately reopened
                if (!modal.classList.contains('is-open')) {
                    modalContent.innerHTML = '';
                    modalLinkContainer.innerHTML = '';
                    modal.removeAttribute('aria-labelledby'); // Clean up ARIA attribute
                }
            }, 300);

            // Return focus to the element that opened the modal, or fallback
            if (appState.lastFocusedElement && typeof appState.lastFocusedElement.focus === 'function') {
                // Use requestAnimationFrame to ensure focus happens after potential DOM updates
                // and the element is focusable again (e.g., not hidden by loading state).
                 requestAnimationFrame(() => {
                    try {
                        appState.lastFocusedElement.focus({ preventScroll: true }); // Prevent scrolling jump
                    } catch (e) {
                         console.warn("[FE] Failed to return focus to last element.", e);
                         searchInput.focus(); // Fallback focus
                    }
                 });
            } else {
                searchInput.focus(); // Fallback focus if last element is gone or invalid
            }
            appState.lastFocusedElement = null; // Clear the stored element
        }

        // --- Main Search Orchestration ---

        /** Initiates a search request based on current form values and page number. */
        async function performSearch(pageNumber = 1) {
            if (appState.isLoading) {
                console.log('%c[FE] Search ignored, already processing.', 'color: gray');
                return; // Prevent concurrent searches
            }

            const query = searchInput.value.trim();
            const driver = driverSelect.value;
            const type = typeSelect.value; // Get selected type

            if (!query) {
                showError('Please enter a search query.');
                searchInput.focus(); // Focus input if query is missing
                return;
            }
            hideError(); // Clear any previous errors

            // Update state *before* making the async API call
            appState.currentPage = pageNumber;
            appState.currentQuery = query;
            appState.currentDriver = driver;
            appState.currentType = type; // Store current type in state

            setSearchState(true); // Enter loading state (disables inputs, shows skeletons)
            console.log(`%c[FE] Performing search: Q='${query}', Driver='${driver}', Type='${type}', Page=${pageNumber}`, 'color: yellow');

            // Fetch results using the updated state
            const result = await fetchResultsFromApi(appState.currentQuery, appState.currentDriver, appState.currentType, appState.currentPage);

            // --- State Check After Await ---
            // Crucial check: Only process the result if the current state *still* matches the state
            // when this specific request was initiated. Prevents race conditions.
            if (query === appState.currentQuery && driver === appState.currentDriver && type === appState.currentType && pageNumber === appState.currentPage) {
                setSearchState(false); // Exit loading state

                if (result.success) {
                    displaySearchResults(result.data); // Display results if successful
                } else {
                    showError(result.error || 'Failed to fetch results.'); // Display error message
                    appState.resultsCache = []; // Clear cache on error
                    updatePaginationButtons(0); // Update pagination (will hide it due to error)
                }
            } else {
                // If state changed while waiting, discard this result
                console.log(`%c[FE] Search result ignored, state changed during request. (Current: ${appState.currentQuery}/${appState.currentDriver}/${appState.currentType}/p${appState.currentPage})`, 'color: gray');
                // Do not call setSearchState(false) here, as another request is likely in progress which will handle it.
            }
        }

        // --- Event Listeners ---

        // Search button click
        searchBtn.addEventListener('click', () => performSearch(1)); // Always start search from page 1

        // Enter key in search input
        searchInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault(); // Prevent potential form submission if wrapped in form
                searchBtn.click(); // Trigger search button click
            }
        });

        // Pagination buttons
        prevBtn.addEventListener('click', () => {
            if (!prevBtn.disabled) performSearch(appState.currentPage - 1);
        });
        nextBtn.addEventListener('click', () => {
            if (!nextBtn.disabled) performSearch(appState.currentPage + 1);
        });

        // Modal close button
        closeModalBtn.addEventListener('click', closeModal);

        // Click outside modal content to close
        modal.addEventListener('click', (e) => {
            // Close only if the click is directly on the modal backdrop itself
            if (e.target === modal) {
                closeModal();
            }
        });

        // Escape key to close modal
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && modal.classList.contains('is-open')) {
                closeModal();
            }
        });

        // Focus Trapping within Modal
        modal.addEventListener('keydown', (e) => {
            if (e.key === 'Tab' && modal.classList.contains('is-open')) {
                // Find all focusable elements within the modal
                const focusableElements = Array.from(
                    modal.querySelectorAll('button, [href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex="-1"])')
                ).filter(el => el.offsetParent !== null); // Ensure element is visible and focusable

                if (!focusableElements.length) {
                    e.preventDefault(); // No focusable elements, prevent tabbing away
                    return;
                }

                const firstElement = focusableElements[0];
                const lastElement = focusableElements[focusableElements.length - 1];

                if (e.shiftKey) { // Shift + Tab
                    if (document.activeElement === firstElement) {
                        lastElement.focus(); // Wrap to last element
                        e.preventDefault();
                    }
                } else { // Tab
                    if (document.activeElement === lastElement) {
                        firstElement.focus(); // Wrap to first element
                        e.preventDefault();
                    }
                }
                // Allow natural tab order within the modal otherwise
            }
        });

        // --- Initialization ---
        window.addEventListener('load', () => {
            console.log('%c[FE] Neon Search Interface Initialized.', 'color: lightgreen');
            // Ensure initial state is clean
            modal.classList.remove('is-open');
            paginationControls.classList.add('hidden');
            errorMessage.classList.add('hidden');
            errorMessage.setAttribute('aria-hidden', 'true'); // Ensure hidden from AT initially

            // Sync initial state from dropdowns (in case HTML defaults change)
            appState.currentDriver = driverSelect.value;
            appState.currentType = typeSelect.value;

            // Set initial focus for usability
            searchInput.focus();
        });

    </script>
</body>
</html>
EOF

# --- Final Instructions ---
echo ""
success "Project '$PROJECT_NAME' setup complete!"
echo ""
info "To run the application:"
info "1. Navigate to the project directory: cd $PROJECT_NAME"
info "2. Start the backend server: node server.cjs"
info "3. Open your web browser and go to: http://localhost:3001 (or the port specified in .env)"
echo ""
info "The script '$0' has finished."

[end of setup_porn.sh]
